#!/usr/bin/env python

import argparse
import fixfmt
import fixfmt.table
import json
import logging
from   ora import Time, Daytime, now, get_display_time_zone
import sys

from   apsis.lib.argparse import HelpFormatter
import apsis.service.client

#-------------------------------------------------------------------------------

if sys.stdout.isatty():
    BLD = "\x1b[1m"
    NBL = "\x1b[0m"
    UND = "\x1b[4m"
    NUN = "\x1b[24m"
    BLK = "\x1b[30m"
    RED = "\x1b[31m"
    GRN = "\x1b[32m"
    YEL = "\x1b[33m"
    BLU = "\x1b[34m"
    MAG = "\x1b[35m"
    CYN = "\x1b[36m"
    WHT = "\x1b[37m"

else:
    BLD = ""
    NBL = ""
    UND = ""
    NUN = ""
    BLK = ""
    RED = ""
    GRN = ""
    YEL = ""
    BLU = ""
    MAG = ""
    CYN = ""
    WHT = ""

STATE_COLOR = {
    "new"       : CYN,
    "scheduled" : WHT,
    "running"   : BLU,
    "success"   : GRN,
    "failure"   : MAG,
    "error"     : RED,
}

#-------------------------------------------------------------------------------

def parse_at_time(string):
    """
    Parses a time for when to run.

    Accepts a full time or a daytime (next occurrence).
    """
    if string == "now":
        return "now"

    try:
        return Time(string)
    except ValueError:
        pass

    try:
        daytime = Daytime(string)
    except ValueError:
        pass
    else:
        # Assume this is today's daytime in the display time zone, unless
        # that has already passed, in which case use tomorrow.
        z = get_display_time_zone()
        date, daytime_now = now() @ z
        return (date if daytime_now < daytime else date + 1, daytime) @ z

    raise ValueError(f"cannot interpret as time: {string}")


def print_lines(lines):
    for line in lines:
        print(line)


def prefix(prefix, lines):
    for line in lines:
        yield prefix + line


def format_jso(jso, indent=0):
    ind = " " * indent
    wid = 12 - indent
    for key, value in jso.items():
        yield f"{ind}{key:{wid}s}: {value}"


def format_program(program, indent=0):
    yield from format_jso(program, indent=indent)


def format_schedule(schedule, indent=0):
    yield from format_jso(schedule, indent=indent)


def format_job(job):
    # fmt = lambda k, v: f"{k:12s}: {v}"
    # yield fmt("job_id", job["job_id"])
    # yield fmt("url", job["url"])
    # yield fmt("params", ", ".join(job["params"]))
    # yield "program"
    # yield from format_program(job["program"], indent=2)
    # yield "schedules"
    # for schedule in job["schedules"]:
    #     yield from format_schedule(schedule, indent=2)
    yield from _fmt(None, job)


def _fmt(name, val, width=16, indent=-2):
    prefix = " " * indent
    if isinstance(val, dict):
        if name is not None:
            yield prefix + name + ":"
        for name, val in val.items():
            yield from _fmt(name, val, width, indent + 2)
    elif isinstance(val, list):
        if name is not None:
            yield prefix + name + ":"
        for val in val:
            yield from _fmt("-", val, width, indent + 2)
    else:
        if name is None:
            name = ""
        yield prefix + fixfmt.pad(name, width - indent) + ": " + str(val)


def format_run(run):
    b = "✦"
    run_id = run["run_id"]
    yield f"{BLD}run {GRN}{run_id}{BLK}{NBL}"

    job = (
        run["job_id"]
        + (
            "with " + " ".join( 
                f"{k}={CYN}{v}{BLK}" 
                for k, v in run["args"].items() 
            )
            if len(run["args"]) > 0
            else ""
        )
    )
    yield f"{b} job        {CYN}{job}{BLK}"

    if run["rerun"] != run_id:
        yield f"{b} rerun of   run {GRN}{run['rerun']}{BLK}"

    state = run["state"]
    if state == "scheduled":
        time = "for " + run["times"].get("schedule", "?")
    elif state == "running":
        time = "since " + run["times"].get("running", "?")
    else:
        time = "at " + run["times"].get(state, "?")
    yield f"{b} {STATE_COLOR[state]}{state:10s}{BLK} {time}"

    if run["message"] is not None:
        yield f"➔ {WHT}{run['message']}{BLK}"
    
    yield ""



def format_elapsed(secs):
    secs = round(secs)
    if secs < 3600:
        return f"   {secs // 60:2d}:{secs % 60:02d}"
    else:
        return f"{secs // 3600:2d}:{secs // 60 % 60:02d}:{secs % 60:02d}"
    # FIXME: Add formats for longer times.

format_elapsed.width = 8


def format_time(time):
    return format(Time(time), "%D %C@")

format_time.width = 19


#-------------------------------------------------------------------------------

logging.basicConfig(
    format  ="%(asctime)s %(name)-24s [%(levelname)-7s] %(message)s",
    datefmt ="%H:%M:%S",
    level   =logging.WARNING,
)

parser = argparse.ArgumentParser(
    usage="%(prog)s [ OPTIONS ] COMMAND ...",
    formatter_class=HelpFormatter,
)
parser.add_argument(
    "--host", metavar="HOST", default="localhost",
    help="connect to HOST [def: localhost]")
parser.add_argument(
    "--port", metavar="PORT", default=apsis.service.DEFAULT_PORT,
    help=f"connect to PORT [def: {apsis.service.DEFAULT_PORT}]")
parser.add_argument(
    "--log-level", metavar="LEVEL", default="WARNING",
    choices={"DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"},
    help="log at LEVEL [def: WARNING]")
commands = parser.add_subparsers(title="commands")

def add_command(name, fn, description=None):
    cmd = commands.add_parser(
        name, 
        formatter_class =HelpFormatter, 
        description     =description,
    )
    cmd.set_defaults(cmd=fn)
    return cmd


#--- command: job --------------------------------------------------------------

def cmd_job(client, args):
    job_id = args.job  # FIXME
    job = client.get_job(job_id)
    print_lines(format_job(job))


cmd = add_command(
    "job", cmd_job,
    description="Displays a job.")
cmd.add_argument(
    "job", metavar="JOB-ID",
    help="display job with JOB-ID")

#--- command: jobs -------------------------------------------------------------

def cmd_jobs(client, args):
    jobs = client.get_jobs()

    table = fixfmt.table.RowTable()
    table.extend(
        {
            "job_id": job["job_id"],
            "params": ", ".join(job["params"]),
        }
        for job in jobs
    )
    table.print()
    print()


cmd = add_command(
    "jobs", cmd_jobs,
    description="Lists all jobs.")

#--- command: output -----------------------------------------------------------

def cmd_output(client, args):
    run_id = args.run_id
    output = client.get_output(run_id)
    sys.stdout.buffer.write(output)


cmd = add_command(
    "output", cmd_output,
    description="Dumps the output of a run.")
cmd.add_argument(
    "run_id", metavar="RUN-ID")

#--- command: run --------------------------------------------------------------

def cmd_run(client, args):
    run_id = args.run_id  # FIXME
    run = client.get_run(run_id)
    if args.json:
        json.dump(run, sys.stdout, indent=2)
    else:
        print_lines(format_run(run))


cmd = add_command(
    "run", cmd_run,
    description="Displays a run.")
cmd.add_argument(
    "run_id", metavar="RUN-ID")
cmd.add_argument(
    "--json", action="store_true", default=False,
    help="dump run as JSON")

#--- command: runs -------------------------------------------------------------

def cmd_runs(client, arg):
    job_id = args.job  # FIXME
    runs = client.get_job_runs(job_id)

    table = fixfmt.table.RowTable()

    table.extend(
        {
            "run_id"    : run["run_id"],
            **run["args"],
            "start"     : run["times"].get("running", run["times"]["schedule"]),
            "state"     : run["state"],
            "elapsed"   : run["meta"].get("elapsed"),
        }
        for run in sorted(runs.values(), key=lambda r: r["times"]["schedule"])
    )
    table.fmts["start"] = format_time
    table.fmts["elapsed"] = format_elapsed
    table.print()
    print()


cmd = add_command(
    "runs", cmd_runs,
    description="Displays runs of a job.")
cmd.add_argument(
    "job", metavar="JOB-ID")

#--- command: schedule ---------------------------------------------------------

def cmd_schedule(client, args):
    time = parse_at_time(args.time)
    # FIXME: Accept daytimes.
    if args.shell:
        command = " ".join(args.command)
        run = client.schedule_shell_program(time, command)
    else:
        run = client.schedule_program(time, args.command)
    print_lines(format_run(run))


cmd = add_command(
    "schedule", cmd_schedule,
    description="Schedules a custom ad hoc run.")
cmd.add_argument(
    "time", metavar="TIME",
    help="time to run, or NOW")
cmd.add_argument(
    "command", metavar="CMD...", nargs="+",
    help="command to run")
cmd.add_argument(
    "--shell", action="store_true", default=False,
    help="treat CMD as shell code (contactenated)")

#-------------------------------------------------------------------------------

args = parser.parse_args()
logging.getLogger().setLevel(getattr(logging, args.log_level))
client = apsis.service.client.Client(host=args.host, port=args.port)
args.cmd(client, args)

