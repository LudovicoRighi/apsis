#!/usr/bin/env python

import json
import logging
from   ora import now
import random
import sys

from   apsis.cmdline import format_job, format_jobs, format_run, format_runs
from   apsis.cmdline import parse_at_time, print_lines
import apsis.jobs
import apsis.lib.argparse
import apsis.lib.itr
import apsis.lib.logging
from   apsis.runs import Run
import apsis.service.client

apsis.lib.logging.configure()
log = logging.getLogger(__name__)

#-------------------------------------------------------------------------------
# top-level argument parser

default_host, default_port = apsis.service.client.get_host()

parser = apsis.lib.argparse.CommandArgumentParser()
parser.add_argument(
    "--host", metavar="HOST", default=default_host,
    help=f"connect to HOST [def: {default_host}]")
parser.add_argument(
    "--port", metavar="PORT", default=default_port,
    help=f"connect to PORT [def: {default_port}]")

#--- command: adhoc ------------------------------------------------------------

def cmd_adhoc(client, args):
    time = parse_at_time(args.time)
    if args.shell:
        command = " ".join(args.command)
        run = client.schedule_shell_program(time, command)
    else:
        run = client.schedule_program(time, args.command)
    print_lines(format_run(run))


cmd = parser.add_command(
    "adhoc", cmd_adhoc,
    description="Creates and schedules an ad hoc run.")
cmd.add_argument(
    "time", metavar="TIME",
    help="time to run [time, daytime, 'now']")
cmd.add_argument(
    "command", metavar="CMD...", nargs="+",
    help="command to run")
cmd.add_argument(
    "--shell", action="store_true", default=False,
    help="treat CMD as shell code (contactenated)")

#--- command: job --------------------------------------------------------------

def cmd_job(client, args):
    job_id = args.job  # FIXME
    job = client.get_job(job_id)
    if args.json:
        json.dump(job, sys.stdout, indent=2)
    else:
        print_lines(format_job(job))


cmd = parser.add_command(
    "job", cmd_job,
    description="Displays a job.")
cmd.add_argument(
    "job", metavar="JOB-ID",
    help="display job with JOB-ID")
cmd.add_argument(
    "--json", action="store_true", default=False,
    help="dump run as JSON")

#--- command: jobs -------------------------------------------------------------

def cmd_jobs(client, args):
    jobs = client.get_jobs()
    print_lines(format_jobs(jobs))
    print()


cmd = parser.add_command(
    "jobs", cmd_jobs,
    description="Lists all jobs.")

#--- command: output -----------------------------------------------------------

def cmd_output(client, args):
    # FIXME: For now, expose output_id=output only.
    output = client.get_output(args.run_id, "output")
    sys.stdout.buffer.write(output)


cmd = parser.add_command(
    "output", cmd_output,
    description="Dumps the output of a run.")
cmd.add_argument(
    "run_id", metavar="RUN-ID")

#--- command: rerun ------------------------------------------------------------

def cmd_rerun(client, arg):
    run = client.rerun(arg.run_id)
    if args.json:
        json.dump(run, sys.stdout, indent=2)
    else:
        print_lines(format_run(run))


cmd = parser.add_command(
    "rerun", cmd_rerun,
    description="Reruns a failed (or error) run.")
cmd.add_argument(
    "run_id", metavar="RUN-ID")
cmd.add_argument(
    "--json", action="store_true", default=False,
    help="dump run as JSON")

#--- command: run --------------------------------------------------------------

def cmd_run(client, args):
    for run_id in args.run_id:
        run = client.get_run(run_id)
        if args.json:
            json.dump(run, sys.stdout, indent=2)
        else:
            print_lines(format_run(run))


cmd = parser.add_command(
    "run", cmd_run,
    description="Displays a run.")
cmd.add_argument(
    "run_id", metavar="RUN-ID", nargs="+")
cmd.add_argument(
    "--json", action="store_true", default=False,
    help="dump run as JSON")

#--- command: runs -------------------------------------------------------------

def cmd_runs(client, arg):
    runs = client.get_runs(
        job_id  =args.job,
        reruns  =args.reruns,
        state   =args.state,
        # FIXME: times
    )

    if args.json:
        json.dump(runs, sys.stdout, indent=2)
    elif args.summary:
        for run in runs.values():
            print_lines(format_run(run))
    else:
        print_lines(format_runs(runs, reruns=args.reruns))


cmd = parser.add_command(
    "runs", cmd_runs,
    description="Queries and displays runs.")
cmd.add_argument(
    "--job", "-j", metavar="JOB-ID", default=None,
    help="show only runs of job JOB-ID")
cmd.add_argument(
    "--reruns", action="store_true", default=False,
    help="show RUN-ID and its reruns")
cmd.add_argument(
    "--state", "-s", metavar="STATE", default=None,
    choices=[ r.name for r in Run.STATE ],
    help="show only runs in STATE")
cmd.add_argument(
    "--times", "-t", metavar="TIMESPAN", default=None,
    help="show only runs in TIMESPAN")

grp = cmd.add_mutually_exclusive_group()
grp.add_argument(
    "--summary", action="store_true", default=False,
    help="summarize each run")
grp.add_argument(
    "--json", action="store_true", default=False,
    help="output as JSON")

#--- command: schedule ---------------------------------------------------------

def cmd_schedule(client, args):
    run = client.schedule(args.job_id, dict(args.args), args.time)
    print_lines(format_run(run))


def parse_arg(arg):
    name, value = arg.split("=", 1)
    return name, value


cmd = parser.add_command(
    "schedule", cmd_schedule,
    description="Creates and schedules a run.")
cmd.add_argument(
    "time", metavar="TIME", type=parse_at_time,
    help="time to run [time, daytime, 'now']")
cmd.add_argument(
    "job_id", metavar="JOB-ID",
    help="run an instance of JOB-ID")
cmd.add_argument(
    "args", metavar="NAME=VAL", type=parse_arg, nargs="*",
    help="run JOB-ID with NAME=VAL")

#--- test commands -------------------------------------------------------------

def cmd_test0(client, args):
    time = now()
    past = args.past
    rng = args.fut - past

    for i in range(args.num):
        run = client.schedule("reruntest", {"id": i}, time + past + rng * random.random())
        log.info(f"scheduled: {run['run_id']}")

cmd = parser.add_command(
    "test0", cmd_test0, 
    description="[TEST] Schedule reruntest.")
cmd.add_argument("num", metavar="NUM", type=int, nargs="?", default=1)
cmd.add_argument("fut", metavar="SECS", type=float, nargs="?", default=60)
cmd.add_argument("past", metavar="SECS", type=float, nargs="?", default=0)

#-------------------------------------------------------------------------------

args = parser.parse_args()
client = apsis.service.client.Client(host=args.host, port=args.port)

try:
    args.cmd(client, args)
except apsis.service.client.APIError as err:
    print(err, file=sys.stderr)
    raise SystemExit(1)
except (KeyboardInterrupt, BrokenPipeError):
    pass

