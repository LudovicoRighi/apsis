#!/usr/bin/env python

import json
import logging
import os
import ora
from   pathlib import Path
import sys

import apsis.config
import apsis.lib.argparse
import apsis.lib.logging
from   apsis.service import DEFAULT_PORT
import apsis.service.client
import apsis.service.main
from   apsis.sqlite import SqliteDB, archive_runs

#-------------------------------------------------------------------------------

apsis.lib.logging.configure()
log = logging.getLogger(__name__)

parser = apsis.lib.argparse.CommandArgumentParser()
addr = apsis.service.client.get_address()
parser.add_argument(
    "--host", metavar="HOST", default=addr.host,
    help=f"connect to HOST [def: {addr.host}]")
parser.add_argument(
    "--port", metavar="PORT", default=addr.port,
    help=f"connect to PORT [def: {addr.port}]")

def get_client(args):
    return apsis.service.client.Client((args.host, args.port))


#-------------------------------------------------------------------------------
# command: archive

def cmd_archive(args):
    db = SqliteDB.open(args.db)
    archive_db = SqliteDB.create(args.archive_db)
    time = ora.Time(args.time)

    archive_runs(db, archive_db, time, delete=args.delete)
    

cmd = parser.add_command(
    "archive", cmd_archive,
    description="Moves old runs to an archive DB.")
cmd.add_argument(
    "db", metavar="DBPATH",
    help="path to Apsis database")
cmd.add_argument(
    "archive_db", metavar="ARCPATH",
    help="path to archive database")
cmd.add_argument(
    "time", metavar="TIME", type=ora.Time,
    help="archive runs before TIME")
cmd.add_argument(
    "--delete", action="store_true", default=False,
    help="delete archived runs from DBPATH")

#-------------------------------------------------------------------------------
# command: check-job

def cmd_check_job(args):
    path = args.path
    job = apsis.jobs.check_job_file(path)
    if job is not None:
        # FIXME: Use something nicer.
        json.dump(apsis.jobs.job_to_jso(job), sys.stdout, indent=2)


cmd = parser.add_command(
    "check-job", cmd_check_job,
    description="Checks a job file.")
cmd.add_argument(
    "path", metavar="PATH",
    help="check the job file PATH")

#-------------------------------------------------------------------------------
# command: create

def cmd_create(args):
    SqliteDB.create(args.state_path)


cmd = parser.add_command(
    "create", cmd_create,
    description="Initializes an Apsis state file.")
cmd.add_argument(
    "state_path", metavar="PATH",
    help="state file")

#-------------------------------------------------------------------------------
# command: migrate

def cmd_migrate(args):
    SqliteDB.migrate(args.state_path)


cmd = parser.add_command(
    "migrate", cmd_migrate,
    description="Migrates an Apsis state file.")
cmd.add_argument(
    "state_path", metavar="PATH",
    help="state file")

#-------------------------------------------------------------------------------
# command: reload_jobs

def cmd_reload_jobs(args):
    get_client(args).reload_jobs()


cmd = parser.add_command(
    "reload-jobs", cmd_reload_jobs,
    description="Reloads jobs from the jobs dir.")

#-------------------------------------------------------------------------------
# command: restart

def cmd_restart(args):
    get_client(args).shut_down(restart=True)


cmd = parser.add_command(
    "restart", cmd_restart,
    description="Restarts the Apsis service.")

#-------------------------------------------------------------------------------
# command: serve

def cmd_serve(args):
    config = apsis.config.load(args.config)
    for ovr in args.override:
        name, val = ovr.split("=", 1)
        config[name] = val

    restart = apsis.service.main.serve(
        config, host=args.host, port=args.port, debug=args.debug)

    if restart:
        # Start all over.
        argv = [sys.executable, *sys.argv]
        log.info(f"restarting: {' '.join(argv)}")
        log.info("...")
        os.execv(argv[0], argv)


cmd = parser.add_command(
    "serve", cmd_serve,
    description="Runs the Apsis service.")

cmd.add_argument(
    "--debug", action="store_true", default=False,
    help="run in debug mode")
# FIXME: Host, port collide with global options.
# FIXME: Can't use localhost on OSX, where it resolves to an IPV6 address,
# until we pick up this Sanic fix:
# https://github.com/channelcat/sanic/pull/1053
cmd.add_argument(
    "--host", metavar="HOST", default="127.0.0.1",
    help="server host address")
cmd.add_argument(
    "--port", metavar="PORT", type=int, default=DEFAULT_PORT,
    help=f"server port [def: {DEFAULT_PORT}]")
cmd.add_argument(
    "--config", metavar="CFGFILE", nargs="?", type=Path, default=None,
    help="read config from CFGFILE")
cmd.add_argument(
    "--override", "-o", metavar="NAME=VAL", action="append", default=[],
    help="override config NAME as VAL")


#-------------------------------------------------------------------------------
# command: shut_down

def cmd_shut_down(args):
    get_client(args).shut_down()


cmd = parser.add_command(
    "shut_down", cmd_shut_down,
    description="Shuts down the Apsis service.")

#-------------------------------------------------------------------------------

args = parser.parse_args()

try:
    args.cmd(args)
except apsis.service.client.APIError as err:
    print(err, file=sys.stderr)
    raise SystemExit(1)
except (KeyboardInterrupt, BrokenPipeError):
    pass

